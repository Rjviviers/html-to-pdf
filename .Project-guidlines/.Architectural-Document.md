Architectural Document: WeasyPrint/Python/Tauri Stack
1. Introduction:
This document outlines the technical architecture for a high-throughput, cross-platform HTML-to-PDF conversion utility. The chosen technology stack is WeasyPrint (conversion engine), Python (backend processing), and Tauri (GUI framework). This architecture is designed for performance, scalability, and maintainability, with a focus on fulfilling the core requirements of batch processing and automatic bookmark generation.

2. System Architecture Overview:


The application employs a decoupled, two-part architecture: a lightweight frontend built with Tauri and a powerful backend processing engine written in Python. These two components are bundled into a single, self-contained application package using the sidecar pattern.

 - Frontend (Tauri): A cross-platform GUI built with standard web technologies (HTML, CSS, JavaScript). It is responsible for all user interaction, including file selection and progress display.

 - Backend (Python Sidecar): A standalone Python executable, created using PyInstaller. It contains all the core logic for PDF conversion, job queueing, and parallel processing.   

 - Integration: The Tauri application's Rust core is responsible for the lifecycle management of the Python sidecar process. It spawns the sidecar on application start-up and ensures it is terminated gracefully on exit.   

3. Component Breakdown
3.1. Frontend: Tauri GUI Framework: Tauri.   
Technology: Standard HTML, CSS, and JavaScript for the UI.
Responsibilities: Provide a file/folder selection dialog.
Display the list of files to be converted.
Visualize the real-time progress of the batch job (e.g., progress bar, status list).
Initiate the conversion process by sending the file list to the backend.
Backend Communication:
Receiving Updates: The frontend establishes a WebSocket connection to the Python backend upon startup. It listens for messages from the server (e.g.,    
job_complete, job_failed, batch_progress) and updates the UI accordingly.   
Sending Commands: User actions, such as starting a conversion, are communicated to the backend via Tauri's internal command system, which can trigger a local HTTP request to an endpoint exposed by the Python sidecar.
3.2. Backend: Python SidecarThe backend is a self-contained executable responsible for all heavy lifting.
Conversion Engine: WeasyPrint
Function: Renders HTML and CSS into paginated PDFs.   
Key Feature: Automatically generates a hierarchical PDF bookmark tree from HTML heading elements (<h1> - <h6>) by default, satisfying a core project requirement without extra processing steps.   
Performance: While potentially resource-intensive for complex documents, performance can be managed by authoring standards-compliant source files and utilizing library features like disk-based image caching to reduce memory usage. Known bottlenecks, such as complex table layouts or specific CSS rules, can be identified and optimized.   
Parallel Processing: multiprocessing Module
Strategy: The application will implement a worker pool model to parallelize the conversion workload. HTML-to-PDF conversion is a CPU-bound task, making process-based parallelism the optimal strategy in Python.   
Implementation: Python's multiprocessing module will be used to spawn a pool of worker processes, bypassing the Global Interpreter Lock (GIL). This allows the application to fully utilize all available CPU cores for concurrent conversions, maximizing throughput for large batches.   
Job Management and Communication
Job Queue: An internal queue (e.g., Python's multiprocessing.Queue) will be used to manage the list of files to be converted. The main backend process populates the queue, and the worker processes consume from it.   
WebSocket Server: The main backend process will run a lightweight WebSocket server (using a library like websockets). As workers complete their tasks, they report their status back to the main process, which then broadcasts these updates to the connected Tauri frontend.   
4. End-to-End WorkflowLaunch: The user executes the application. The Tauri Rust core starts and immediately spawns the packaged Python sidecar executable.   
Initialization: The Python sidecar starts its WebSocket server and initializes the multiprocessing worker pool.
Connection: The Tauri JavaScript frontend connects to the WebSocket server at ws://localhost:[port].
Job Creation: The user selects files. The frontend sends the file paths to the backend. The backend enqueues a conversion job for each file.
Execution: Idle worker processes pull jobs from the queue and use WeasyPrint to perform the HTML-to-PDF conversion.
Reporting: Upon job completion, the worker process communicates the result (success/failure, output path) back to the main backend process.
Notification: The main backend process formats a status message and sends it over the WebSocket to the frontend.
UI Update: The frontend receives the WebSocket message and updates the progress bar and status display.
Shutdown: When the user closes the Tauri window, the Rust core sends a termination signal to the sidecar process, ensuring a clean shutdown.
5. Packaging and DistributionBackend Packaging: The Python application, along with all its dependencies (WeasyPrint, etc.), will be bundled into a single, platform-specific executable using PyInstaller. PyInstaller analyzes the Python code, collects all necessary modules, and creates a self-contained binary that does not require a pre-installed Python interpreter on the user's machine.   
Application Bundling: The tauri.conf.json file will be configured to recognize the PyInstaller-generated executable as a sidecar binary.   
Distribution: Running the tauri build command will trigger the full build process. It will compile the Rust core, bundle the web frontend, and package the Python sidecar into a single, distributable installer. This will produce a .msi installer for Windows and .deb/.AppImage files for Linux, providing a simple and native installation experience for the end-user.   

